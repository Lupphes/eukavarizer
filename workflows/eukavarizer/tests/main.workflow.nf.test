nextflow_workflow {

    name "Test Workflow EUKAVARIZER"
    script "../main.nf"
    workflow "EUKAVARIZER"
    config "workflows/eukavarizer/tests/nextflow.config"
    tag "workflows"
    tag "eukavarizer"

    /*
     * Test scenario 1: SV calling with all callers enabled - Illumina short reads
     * This test validates the complete EUKAVARIZER workflow with all structural variant callers active.
     * Expected behavior: The workflow should execute all 8 SV callers (DELLY, Manta, GRIDSS, DYSGU,
     * TIDDIT, SVABA for short reads, plus Sniffles and CuteSV for long reads) and aggregate their
     * outputs into unified VCF channels. This tests the workflow's ability to use multiple
     * callers simultaneously and merge their results for SV detection.
     */
    test("All SV callers enabled - Illumina - stub") {
        options '-stub'

        when {
            params {
                delly_flag = true
                manta_flag = true
                gridss_flag = true
                dysgu_flag = true
                tiddit_flag = true
                svaba_flag = true
                sniffles_flag = true
                cutesv_flag = true
                bwamem2 = false
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of([
                    [id: 'test', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample1', patient: 'patient1'],
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                ])
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }

    /*
     * Test scenario 2: Short-read specific SV calling - Illumina platform
     * This test validates the workflow with only short-read SV callers enabled.
     * Expected behavior: The workflow should run 6 short-read callers (DELLY, Manta, GRIDSS, DYSGU,
     * TIDDIT, SVABA) while skipping long-read callers (Sniffles, CuteSV). This tests the workflow's
     * conditional execution logic and ensures proper output aggregation when only a subset of callers
     * is active, typical for Illumina short-read sequencing projects.
     */
    test("Only short-read SV callers - stub") {
        options '-stub'

        when {
            params {
                delly_flag = true
                manta_flag = true
                gridss_flag = true
                dysgu_flag = true
                tiddit_flag = true
                svaba_flag = true
                sniffles_flag = false
                cutesv_flag = false
                bwamem2 = false
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of([
                    [id: 'test', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample1', patient: 'patient1'],
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                ])
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }

    /*
     * Test scenario 3: Long-read specific SV calling - ONT/PacBio platform
     * This test validates the workflow with only long-read SV callers enabled.
     * Expected behavior: The workflow should run only 2 long-read callers (Sniffles, CuteSV) while
     * skipping all short-read callers. This tests platform-specific caller selection based on read
     * length (median_bp: 5000) and sequencing technology (platform: 'ont'). Essential for Oxford
     * Nanopore and PacBio long-read sequencing projects where short-read callers are not applicable.
     */
    test("Only long-read SV callers - stub") {
        options '-stub'

        when {
            params {
                delly_flag = false
                manta_flag = false
                gridss_flag = false
                dysgu_flag = false
                tiddit_flag = false
                svaba_flag = false
                sniffles_flag = true
                cutesv_flag = true
                bwamem2 = false
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of([
                    [id: 'test_ont', single_end: true, platform: 'ont', median_bp: 5000, sample: 'sample1', patient: 'patient1'],
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                ])
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }

    /*
     * Test scenario 4: Single caller validation - DELLY only
     * This test validates the workflow when running with a single SV caller.
     * Expected behavior: The workflow should execute only DELLY while skipping all other callers,
     * demonstrating minimal resource usage scenarios. This tests the workflow's ability to handle
     * selective caller execution and proper output channel initialization when most callers are
     * disabled. Useful for quick validation runs or when only specific caller results are needed.
     */
    test("Single SV caller - DELLY only - stub") {
        options '-stub'

        when {
            params {
                delly_flag = true
                manta_flag = false
                gridss_flag = false
                dysgu_flag = false
                tiddit_flag = false
                svaba_flag = false
                sniffles_flag = false
                cutesv_flag = false
                bwamem2 = false
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of([
                    [id: 'test', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample1', patient: 'patient1'],
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                ])
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }

    /*
     * Test scenario 5: SVABA with BWAMEM2 aligner filtering
     * This test validates SVABA caller execution with BWAMEM2 alignment filtering.
     * Expected behavior: The workflow should run only SVABA with bwamem2=true parameter,
     * testing the alignment-specific filtering logic. SVABA has special handling for different
     * aligners (BWA vs BWAMEM2) that affects its SV calling sensitivity. This ensures proper
     * integration with BWAMEM2-aligned BAMs and validates aligner-specific parameter passing.
     */
    test("SVABA filtered by BWAMEM2 - stub") {
        options '-stub'

        when {
            params {
                delly_flag = false
                manta_flag = false
                gridss_flag = false
                dysgu_flag = false
                tiddit_flag = false
                svaba_flag = true
                sniffles_flag = false
                cutesv_flag = false
                bwamem2 = true
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of([
                    [id: 'test', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample1', patient: 'patient1'],
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                ])
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }

    /*
     * Test scenario 6: Multi-sample processing validation
     * This test validates the workflow's ability to process multiple samples in parallel.
     * Expected behavior: The workflow should execute enabled SV callers (DELLY, Manta) on two
     * samples simultaneously, testing parallel processing capabilities and proper output aggregation
     * for batch analysis. This ensures the workflow scales correctly and maintains sample-specific
     * metadata through the calling pipeline, essential for population-scale SV studies.
     */
    test("Multiple samples - stub") {
        options '-stub'

        when {
            params {
                delly_flag = true
                manta_flag = true
                gridss_flag = false
                dysgu_flag = false
                tiddit_flag = false
                svaba_flag = false
                sniffles_flag = false
                cutesv_flag = false
                bwamem2 = false
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of(
                    [
                        [id: 'sample1', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample1', patient: 'patient1'],
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                    ],
                    [
                        [id: 'sample2', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample2', patient: 'patient1'],
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                    ]
                )
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }

    /*
     * Test scenario 7: No SV callers enabled - workflow passthrough
     * This test validates workflow behavior when all SV callers are disabled.
     * Expected behavior: The workflow should complete successfully without executing any SV callers,
     * producing empty output channels. This tests the workflow's ability to handle edge cases where
     * SV calling is skipped (e.g., when users only want alignment/QC without variant calling), and
     * ensures proper empty channel handling throughout the pipeline without errors.
     */
    test("No SV callers enabled - empty output - stub") {
        options '-stub'

        when {
            params {
                delly_flag = false
                manta_flag = false
                gridss_flag = false
                dysgu_flag = false
                tiddit_flag = false
                svaba_flag = false
                sniffles_flag = false
                cutesv_flag = false
                bwamem2 = false
                minimap2_flag = false
                long_read_threshold = 300
            }
            workflow {
                """
                input[0] = channel.of([
                    [id: 'test', single_end: false, platform: 'illumina', median_bp: 150, sample: 'sample1', patient: 'patient1'],
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam', checkIfExists: true),
                    file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/bam/test.paired_end.sorted.bam.bai', checkIfExists: true)
                ])
                input[1] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[2] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.fai', checkIfExists: true)])
                input[3] = channel.value([[], []])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)])
                input[5] = channel.value([[], []])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success }
            )
        }
    }
}
