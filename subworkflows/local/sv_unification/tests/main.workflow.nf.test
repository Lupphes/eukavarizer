nextflow_workflow {

    name "Test Workflow SV_UNIFICATION"
    script "../main.nf"
    workflow "SV_UNIFICATION"
    config "subworkflows/local/sv_unification/tests/nextflow.config"
    tag "subworkflows"
    tag "subworkflows_local"
    tag "sv_unification"

    /*
     * Test scenario 1: Single sample with multiple VCF files for SURVIVOR merge
     * This test validates the SURVIVOR-based merging of multiple SV calls from different callers
     * Expected behavior: Merge VCF files based on breakpoint distance, filter by size, and generate stats
     */
    test("Multiple VCFs - SURVIVOR merge - stub") {
        options '-stub'

        when {
            workflow {
                """
                // Multiple VCF files from different callers for the same sample
                // Using existing test VCF files from nf-core test datasets (gvcf directory for uncompressed VCFs)
                input[0] = channel.of(
                    [[id: 'sample1_cutesv'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gvcf/test.genome.vcf', checkIfExists: true)],
                    [[id: 'sample1_sniffles'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gvcf/test2.genome.vcf', checkIfExists: true)]
                )
                input[1] = channel.of(
                    [[id: 'sample1_cutesv'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/haplotypecaller_calls/test2_haplotc.vcf.gz', checkIfExists: true)],
                    [[id: 'sample1_sniffles'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/paired_mutect2_calls/test_test2_paired_mutect2_calls.vcf.gz', checkIfExists: true)]
                )
                input[2] = channel.of(
                    [[id: 'sample1_cutesv'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/haplotypecaller_calls/test2_haplotc.vcf.gz.tbi', checkIfExists: true)],
                    [[id: 'sample1_sniffles'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/paired_mutect2_calls/test_test2_paired_mutect2_calls.vcf.gz.tbi', checkIfExists: true)]
                )
                input[3] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz.fai', checkIfExists: true)])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success },
                { assert workflow.out.survivor_vcf != null },
                { assert workflow.out.survivor_stats != null },
                { assert workflow.out.concat_vcf != null },
                { assert workflow.out.concat_tbi != null },
                { assert workflow.out.bcfmerge_stats != null },
                { assert snapshot(workflow.out).match() }
            )
        }
    }

    /*
     * Test scenario 2: Single VCF file input
     * This test validates the workflow can handle minimal input (single caller output)
     * Expected behavior: Process single VCF through both SURVIVOR and BCFtools pipelines
     */
    test("Single VCF - minimal input - stub") {
        options '-stub'

        when {
            workflow {
                """
                input[0] = channel.of(
                    [[id: 'sample1'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gvcf/test.genome.vcf', checkIfExists: true)]
                )
                input[1] = channel.of(
                    [[id: 'sample1'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/haplotypecaller_calls/test2_haplotc.vcf.gz', checkIfExists: true)]
                )
                input[2] = channel.of(
                    [[id: 'sample1'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/haplotypecaller_calls/test2_haplotc.vcf.gz.tbi', checkIfExists: true)]
                )
                input[3] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz.fai', checkIfExists: true)])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success },
                { assert workflow.out.survivor_vcf != null },
                { assert workflow.out.survivor_stats != null },
                { assert workflow.out.concat_vcf != null },
                { assert workflow.out.concat_tbi != null },
                { assert workflow.out.bcfmerge_stats != null }
            )
        }
    }

    /*
     * Test scenario 3: Three VCF files to test multiple caller merging
     * This test validates merging of three different VCF files
     * Expected behavior: Merge across multiple VCF files, producing unified output
     */
    test("Three VCFs - complex merge - stub") {
        options '-stub'

        when {
            workflow {
                """
                input[0] = channel.of(
                    [[id: 'sample1_cutesv'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gvcf/test.genome.vcf', checkIfExists: true)],
                    [[id: 'sample1_sniffles'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gvcf/test2.genome.vcf', checkIfExists: true)]
                )
                input[1] = channel.of(
                    [[id: 'sample1_cutesv'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/haplotypecaller_calls/test2_haplotc.vcf.gz', checkIfExists: true)],
                    [[id: 'sample1_sniffles'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/paired_mutect2_calls/test_test2_paired_mutect2_calls.vcf.gz', checkIfExists: true)]
                )
                input[2] = channel.of(
                    [[id: 'sample1_cutesv'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/haplotypecaller_calls/test2_haplotc.vcf.gz.tbi', checkIfExists: true)],
                    [[id: 'sample1_sniffles'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/gatk/paired_mutect2_calls/test_test2_paired_mutect2_calls.vcf.gz.tbi', checkIfExists: true)]
                )
                input[3] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz', checkIfExists: true)])
                input[4] = channel.value([[id: 'genome'], file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta.gz.fai', checkIfExists: true)])
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success },
                { assert workflow.out.survivor_vcf != null },
                { assert workflow.out.survivor_stats != null },
                { assert workflow.out.concat_vcf != null },
                { assert workflow.out.concat_tbi != null },
                { assert workflow.out.bcfmerge_stats != null }
            )
        }
    }
}
